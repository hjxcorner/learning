---
title: TCP和UDP
tags: ["协议", "tcp", "udp"]
categories: ["协议", "TCP和UDP"]
---

## TCP

### 主要特点

1. **TCP是面向连接的运输层协议**。应用程序在使用TCP协议之前，必须先建立TCP连接（三次握手）。在传输数据完毕后，必须释放已经建立的TCP连接。
2. 每一条TCP连接只能有两个 **端点**，每一条TCP连接只能是点对点（一对一）。
3. TCP提供 **可靠交付**服务。通过TCP连接传送数据，无差错、不丢失、不重复，并且按序到达。（丢弃有差错的报文，超时重传）
4. TCP提供 **全双工通信**。TCP允许通信双方的应用进程在任何时候都能发送数据。
5. **面向字节流** 。虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

<!--more-->

### 可靠传输原理

#### 停止等待协议

- 无差错情况：A发送M1给B，B收到M1后向A发送确认。A在收到对M1的确认后再发送M2。

- 出现差错：B接收M1时检测出了差错，就丢弃M1，其他什么也不做（不通知A收到有差错的分组）。A只要超过一段时间没有收到确认，就认为刚才发送的分组丢失了，因而重传前面的分组。（超时重传）

- 确认丢失和确认迟到：B所发送的对M1的确认丢失了。A在设定的超时重传时间内没有收到确认，A在超时计时器到期后就要重传M1。

  此时B的操作：

  - 丢弃这个重复的分组M1，不向上层交付。
  - 向A发送确认。

#### 连续的ARQ协议和滑动窗口协议

停止等待协议的改良版，为了提高信道利用率。

##### 发送方：

多个分组连续发送出去，不需要等待确认。

##### 接收方：

采用累积确认的方式，**对按序到达的最后一个分组进行确认**。

### TCP连接建立和释放

#### TCP报文中比较重要的字段

1. 序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 
2. 确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 
3. 标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下： 
    - URG：紧急指针（urgent pointer）有效。
    - ACK：确认序号有效。
    - PSH：接收方应该尽快将这个报文交给应用层。
    - RST：重置连接。SYN：发起一个新连接。
    - SYN：发起一个新连接。 
    - FIN：释放一个连接。 

#### 建立连接的过程

![](https://pics1.baidu.com/feed/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg?token=c86d4509157378798ebbccbe843486d1&s=9746F8123F5754CA48D574DA0300D0B2)



第一次握手：客户端向服务端发送一条TCP报文，其中：

- 标记位为SYN，表示“请求建立新连接”; 
- 序号为Seq=X（X一般为1）；

第二次握手：服务器端接收到来自客户端的TCP报文之后，返回一段TCP报文，其中： 

- 标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；
- 序号为Seq=y； 
- 确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值； 

第三次握手：客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，返回最后一段TCP报文。其中： 

- 标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）； 
- 序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值； 
- 确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值； 

此后客户端和服务器端进行正常的数据传输。这就是“三次握手”的过程。

#### 释放连接的过程

![](https://pics5.baidu.com/feed/48540923dd54564e5260495ce0006487d0584fb6.jpeg?token=c3a743af38e25ff66deb6a07891be58e&s=C584FC1A71CFF4EE1A75A45203007073)

（1）首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：

标记位为FIN，表示“请求释放连接“；

序号为Seq=U；随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。

（2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：

标记位为ACK，表示“接收到客户端发送的释放连接的请求”；

序号为Seq=V；

确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；随后服务器端开始准备释放服务器端到客户端方向上的连接。客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段

前"两次挥手"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了

（3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：

标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。序号为Seq=W；

确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。

（4）客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：

标记位为ACK，表示“接收到服务器准备好释放连接的信号”。

序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。

确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。

> 与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续"挥手"，以此确保了"四次挥手"的顺利完成。 

## UDP

### 主要特点

1. UDP是**无连接**的，不需要建立连接。
2. UDP使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3. UDP是**面向报文**的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。
4. UDP没有**拥塞控制**，源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但不允许有太大的时延。
5. UDP支持**一对一、一对多、多对一和多对多的交互通信**
6. UDP的**首部开销小**，只有8个字节，比TCP的20个字节的首部要短。 

### 如何使UDP可靠

UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

​         传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

​         实现确认机制、重传机制、窗口确认机制。

​         如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：

​         发送：包的分片、包确认、包的重发

​         接收：包的调序、包的序号确认

​         目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。

